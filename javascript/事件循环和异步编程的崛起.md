![image](../img/timg.jpg)
<br>

## 前言

在单线程环境中编程的缺陷以及如何解决这些缺陷来构建健壮的JavaScript UI。按照惯例，在本文的最后，分享5个如何使用async/ wait编写更简洁代码的技巧。

## 关于作者

一个工作八年的草根程序员。

## 内容

- 为什么单线程是一个限制？
- JavaScript程序的构建块
- 解析事件循环
- setTimeout(…) 是怎么工作的
- ES6的任务队列是什么?
- 回调
- 嵌套回调
- Promise
- Promise Value
- 使用 Promise 还是不用？
- 吞掉错误或异常
- 处理未捕获异常
- ES8中改进了什么 ?Async/await （异步/等待）
- 编写高度可维护性、非易碎异步代码的5个技巧

### 一、为什么单线程是一个限制？

### 二、JavaScript程序的构建块

### 三、解析事件循环

### 四、setTimeout(…) 是怎么工作的

### 五、ES6的任务队列是什么?

### 六、回调

### 七、嵌套回调

### 八、Promise

### 九、使用 Promise 还是不用？

### 十、吞掉错误或异常

### 十一、处理未捕获异常

### 十二、ES8中改进了什么 ?Async/await （异步/等待）

### 十三、编写高度可维护性、非易碎异步代码的5个技巧

- 简介代码
- 错误处理
- 条件
- 堆栈帧
- 调试

#### 13.1 简介代码

使用async/await可以编写更少的代码。每次使用async/await时，都会路过一些不必要的步骤：使用then，创建一个匿名函数来处理响应，例如：

```
// rp是一个请求Promise函数。
rp('https://api.example.com/endpoint1').then(function(data){

});

```

和：

```
// `rp` is a request-promise function.

var response = await rp(‘https://api.example.com/endpoint1');

```

#### 13.2 错误处理

Async/wait可以使用相同的代码结构（众所周知的try/catch语句）处理同步和异步错误。看看它是如何与Promise结合的

```
function loadData(){
    try{
        getJSON().then(function(response){
            var parsed = JSON.parse(response);
            console.log(parsed);
        }).catch(function(e){
            console.log(e);
        })
    }catch(e){
        console.log(e);
    }
}

```

与

```
async function loadData(){
    try{
        var data = JSON.parse(await getJSON());
        console.log(data);
    }catch(e){
        console.log(e);
    }
}

```

#### 13.3 条件

用async/wait编写代码要简单得多

```
function loadData(){
    return getJSON().then(function(response){
        if(response.needsAnotherRequest){
            return makeAnotherRequest(response).then(function(anotherResponse){
                console.log(anotherResponse);
                return anotherResponse;
            })
        }else{
            console.log(response)
            return response;
        }
    })
}

```

与

```
async function loadData(){
    var response = await getJSON();
    if(response.needsAnotherRequest){
        var anotherResponse = await makeAnotherRequest(response);
        console.log(anotherResponse);
        return anotherResponse;
    }else{
        console.log(response);
        return response;
    }
}

```

#### 13.4 堆栈帧

与async/await不同，从Promise链返回的错误堆栈不提供错误发生在哪里。看下面这些

```
function loadData(){
    return callAPromise().then(callback1).then(callback2).then(callback3).then(()=>{
        throw new Error('boom');
    })
}

loadData().catch(function(e){
    console.log(err);
});

```

与：

```
async function loadData(){
    await callAPromise1();
    await callAPromise2();
    await callAPromise3();
    await callAPromise4();
    await callAPromise5();
    throw new Error('boom');
}

loadData.catch(function(e){
    cosnole.log(e);
})

```

#### 13.1 调试

如果你使用过Promise，那么你知道调试它们是一场噩梦。例如，如果在一个程序中设置了一个断点，然后阻塞并使用高度快捷方式（如“停止”），调试器将不会移动到下面，因为它只“逐步”执行同步代码。使用`async/wait`，您可以逐步完成`wait`调用，就像它们是正常的同步函数一样。

### 参考资料

- [JavaScript是如何工作的:事件循环和异步编程的崛起+ 5种使用 async/await 更好地编码方式！](https://github.com/qq449245884/xiaozhi/issues/4)

## 联系作者

<div align="center">
    <p>
        平凡世界，贵在坚持。
    </p>
    <img src="../img/contact.png" />
</div>