![image](../img/timg.jpg)
<br>

## 前言

本人平时学习及收集内容，欢迎参入一起讨论。

## 关于作者

一个工作八年的草根程序员。

## 内容

- [实现一个 new 操作符](#一实现一个new操作符)
- [实现一个 JSON.stringify](#二实现一个JSON.stringify)
- [实现一个 JSON.parse](#三实现一个JSON.parse)
- [实现一个 call 或 apply](#四实现一个call或apply)
- [实现一个 Function.bind](#五实现一个Function.bind)
- [实现一个继承](#六实现一个继承)
- [实现一个 JS 函数柯里化](#七实现一个JS函数柯里化)
- [手写一个 Promise(中高级必考)](<#八手写一个Promise(中高级必考)>)
- [手写防抖(Debouncing)和节流(Throttling)](<#九手写防抖(Debouncing)和节流(Throttling)>)
- [手写一个 JS 深拷贝](#十手写一个JS深拷贝)
- [实现一个 instanceOf](#十一实现一个instanceOf)
- 实现一个基本的 Event Bus
- Object.create 的基本实现原理
- 使用 setTimeout 模拟 setInterval
- 简单实现一个双向数据绑定
- 实现一个简单路由
- 实现懒加载
- rem 实现原理
- 手写实现 AJAX
- 实现拖拽
- 解析 URL Params 为对象
- 模板引擎实现
- 转化为驼峰命名
- 查找字符串中出现最多的字符和个数
- 字符串查找
- 实现千位分隔符
- 判断是否是电话号码
- 验证是否是邮箱
- 验证是否是身份证

### 一、实现一个 new 操作符

[参考文章](https://github.com/cs-learning-record/javascript-series/blob/master/javascript/new%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0.md)

### 二、实现一个 JSON.stringify

> JSON.stringify(value[,replacer[,space]]);

- `Boolean|Number|String`类型会自动转换成对应的原始值。
- `undefined`、做生意函数以及`symbol`，会被忽略（出现在非数组对象的属性值中时），或者被转换成`null`(出现在数组中时)。
- 不可枚举的属性会被忽略
- 如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略。

```
function jsonStringify(obj){
    let type = typeof obj;
    if(type !=='object' || type === null){
        if (/string|undefined|function/.test(type)){
            obj = '"' + obj + '"';
        }
        return String(obj);
    }else{
        let json = []
        arr = (obj && obj.constructor === Array);
        for (let k in obj){
            let v = obj[k];
            let type = typeof v;
            if(/string|unefined|function/.test(type)){
                v = '"'+ v + '"';
            }else if (type === "object"){
                v = jsonStringify(v);
            }
            json.push((arr ? "" : '"'+ k + '":')+ String(v));
        }
        return (arr ? "[":"{")+ String(json) + (arr ? "]":"}")
    }
}
```

### 三、实现一个 JSON.parse

> JSON.parse(text[,reviver])

用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象。提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换(操作)。

```
function jsonParse(opt){
    return eval('('+opt+')');
}
```

### 四、实现一个 call 或 apply

[参考文章](https://github.com/cs-learning-record/javascript-series/blob/master/javascript/apply%26bind%26call%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0.md)

### 五、实现一个 Function.bind

[参考文章](https://github.com/cs-learning-record/javascript-series/blob/master/javascript/apply%26bind%26call%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0.md)

### 六、实现一个继承

[参考文章](https://github.com/cs-learning-record/javascript-series/blob/master/javascript/%E7%BB%A7%E6%89%BF.md)

### 七、实现一个 JS 函数柯里化

[参考文章](https://github.com/cs-learning-record/javascript-series/blob/master/javascript/函数柯里化.md)

### 八、手写一个 Promise(中高级必考)

```
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

function Promise(excutor){
    let that = this;        // 缓存当前promise实例对象
    that.status = PENDING;  // 初始状态
    that.value = undefined;     // fulfilled状态时 返回的信息
    that.reason = undefined;    // rejected状态时，拒绝的原因
    that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数
    that.onRejectedCallbacks = [];      //存储rejected状态对应的onRejected函数

    function resolve(value){    // value成功态时接收的终值
        if(value instanceof Promise){
            return value.then(resolve,reject);
        }
        //  实践中要确保onFulfilled 和 onRejected方法异步执行，且应该在then方法被调用的那一轮事件循环之后的新执行栈中执行。
        setTimeout(()=>{
            //调用resolve回调对应onFulfilled函数
            if(that.status === PENDING){
                // 只能由pending状态=> fullfilled状态（避免调用多次resolve reject）
                that.status = FULFILLED;
                that.value = value;
                that.onFulfilledCallbacks.forEach(cb=>cb(that.value));
            }
        })
    }
    function reject(reason){    // reason失败态时接收的拒因
        setTimeout(()=>{
            // 调用reject 回调对应onRejected函数
            if (that.status === PENDING){
                // 只能由pending状态 => rejected状态（避免调用多次resolve reject）
                that.status = REJECTED;
                that.reason = reason;
                that.onRejectedCallbacks.forEach(cb=>cb(that.reason));
            }
        });
    }

    // 捕获在excutor执行器中抛出异常
    // new Promise((resolve,reject)=>{
        //   throw new Error('error in excutor')
    // })

    try{
        excutor(resolve,reject);
    }catch(e){
        reject(e);
    }
}

function resolvePromise(promise2,x,resolve,reject){
    var then;
    var thenCalledThrow = false;

    if(promise2 === x){
        return reject(new TypeError('Chaining cycle detected for promise!'))
    }

    if( x instanceof Promise){
        if(x.status === 'pending'){
            x.then(function(v){
                resolvePromise(promise2,v,resolve,reject)
            },reject)
        }else{
            x.then(resolve,reject)
        }
        return
    }

    if((x!==null) && ((typeof x=== 'object') || (typeof x === 'function'))){
        try{
            then = x.then   // because x.then could be a getter
            if(typeof then === 'function'){
                then.call(x,function rs(y){
                    if(thenCalledOrThrow) return
                    thenCalledOrThrow = true
                    reutrn resolvePromise(promise2,y,resolve,reject)
                },function rj(r){
                    if(thenCalledOrThrow) return
                    thenCalledOrThrow = true
                    return reject(r)
                })
            }else{
                resolve(x)
            }
        }catch(e){
            if(thenCalledOrThrow) return
            thenCalledOrThrow = true
            return reject(e)
        }
    }else{
        resolve(x)
    }
}

Promise.prototype.then = function(onFulfilled,onRejected){
    const that = this;
    let newPromise;
    // 处理参数默认值  保证参数后续能够继续执行
    onFulfilled = typeof onFulfilled === "function" ? onFulfilled : value => value;
    onRejected = typeof onRejected === 'function' ? onRejected : reason => {
        throw reason;
    }
    if ( that.status === FULFILLED){    //成功态
        return newPromise = new Promise((resolve,reject) =>{
            setTimeout(()=>{
                try{
                    let x = onFulfilled(that.value);
                    resolvePromise(newPromise,x,resolve,reject);
// 新的promise resolve 上一个onFulfilled的返回值
                }catch(e){
                    reject(e);  //  捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);
                }
            })
        })
    }

    if(that.status === REJECTED){   // 失败态
        return newPromise = new Promise((resolve,reject)=>{
            setTimeout(()=>{
                try{
                    let x = onRejected(that.reason);
                    resolvePromise(newPromise,x,resolve,reject);
                }catch(e){
                    reject(e);
                }
            })
        })
    }

    if(that.status === PENDING){    // 等待态
        // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中
        return newPromise = new Promise((resolve,reject)=>{
            that.onFulfilledCallbacks.push((value)=>{
                try{
                    let x = onFulfilled(value);
                    resolvePromise(newPromise,x,resolve,reject);
                }catch(e){
                    reject(e);
                }
            });
            that.onRejectedCallbacks.push((reason)=>{
                try{
                    let x = onRejected(reason);
                    reasolvePromise(newPromise,x,resolve,reject);
                }catch(e){
                    reject(e);
                }
            })
        })
    }
}

```

### 九、手写防抖(Debouncing)和节流(Throttling)

[参考文章](https://github.com/cs-learning-record/javascript-series/blob/master/javascript/%E9%98%B2%E6%8A%96%E5%8A%A8%E4%B8%8E%E8%8A%82%E6%B5%81.md)

### 十、手写一个 JS 深拷贝

[参考文章](https://github.com/cs-learning-record/javascript-series/blob/master/javascript/%E6%B7%B1%E6%8B%B7%E8%B4%9D.md)

### 十一、实现一个 instanceOf

instanceof 可以判断一个实例是否是其父类型或者祖先类型的实例

instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。

```
    function instanceof(left,right){
        let proto = left.__proto__;
        let prototype = right.prototype;
        while(true){
            if(proto == null) return false
            if(proto == prototype) return true
            proto = proto.__proto__;
        }
    }

```

[代码](https://github.com/ftTony/notes/blob/master/%20InterviewQuestion/instanceof.js)

### 实现一个基本的 Event Bus

```
// 组件通信，一个触发与监听的过程
class EventEmitter{
    constructor(){
        // 存储事件
        this.events = this.events || new Map()
    }
    // 监听事件
    addListener (type,fn){
        if(!this.events.get(type)){
            this.events.set(type,fn)
        }
    }
    // 触发事件
    emit (type) {
        let handle = this.events.get(type);
        handle.apply(this,[...arguments].slice(1))
    }
}

// 测试
let emitter = new EventEmitter()

// 监听事件
emitter.addListener('ages', age => {
    console.log(age)
})

// 触发事件
emiter.emit('ages',18)  // 18

```

### Object.create 的基本实现原理

```
// 思路：将传入的对象作为原型
function create(obj){
    function F(){}
    F.prototype = obj
    return new F()
}

```

### 使用 setTimeout 模拟 setInterval

```
// 可避免setInterval因执行时间导致的间隔执行时间不一致
setTimeout(function(){
    setTimeout(arguments.callee,500)
},500);

```

### 简单实现一个双向数据绑定

```
let obj = {}
let input = document.getElementById('input')
let span = document.getElementById('span')

// 数据劫持
Object.defineProperty(obj,'text',{
    configurable:true,
    enumerable:true,
    get(){
        console.log('获取数据了')
    },
    set(newVal)[
        console.log('数据更新了')
        input.value = newVal
        span.innerHTML = newVal
    ]
})

// 输入监听
input.addEventListener('keyup',function(e){
    obj.text = e.target.value
})

```

### 实现一个简单路由

```
// hash 路由
class Route{
    constructor(){
        // 路由存储对象
        this.router = {}
        // 当前hash
        this.currentHash = ''
        // 绑定this,避免监听时this指向改变
        this.freshRoute = this.freshRoute.bind(this)
        // 监听
        window.addEventListener('load',this.freshRoute,false)
        window.addEventListener('haschange',this.freshRoute,false)
    }
    // 存储
    storeRoute (path,cb){
        this.currentHash = location.hash.slice(1) || '/'
        this.routes[this.currentHash]()
    }
}

```

### 实现懒加载

HTML

```
<ul>
  <li><img src="./imgs/default.png" data="./imgs/1.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/2.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/3.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/4.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/5.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/6.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/7.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/8.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/9.png" alt=""></li>
  <li><img src="./imgs/default.png" data="./imgs/10.png" alt=""></li>
</ul>

```

JS

```

```

### rem 实现原理

```


```

### 手写实现 AJAX

```

```

### 实现拖拽

```

```

### 参考资料

- [20 道 JS 原理题助你面试一臂之力！](https://mp.weixin.qq.com/s/rdVaUJI9ZDLQLFMaI0896A)
- [JavaScript 手写代码无敌秘籍](https://mp.weixin.qq.com/s/4uzNKQcKB5YJbtXF4NQyWg)
- [22 道高频 JavaScript 手写面试题及答案](https://juejin.im/post/5d51e16d6fb9a06ae17d6bbc)

## 联系作者

<div align="center">
    <p>
        平凡世界，贵在坚持。
    </p>
    <img src="../img/contact.png" />
</div>
