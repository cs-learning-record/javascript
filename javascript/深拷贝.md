![image](../img/timg.jpg)
<br>

## 前言

本人平时学习及收集内容，欢迎参入一起讨论。

## 关于作者

一个工作八年的草根程序员。

## 内容

- [理解问题原因所在](#一理解问题原因所在)
- [深拷贝和浅拷贝的区别](#二深拷贝和浅拷贝的区别)
- [实现对象和数组浅拷贝](#三实现对象和数组浅拷贝)
- [实现对象和数组深拷贝](#四实现对象和数组深拷贝)

### 一、理解问题原因所在

JavaScript 中的数据类型可以分为两种：基本类型值（Number,Boolean,String,NULL,Undefined）和引用类型值（Array,Object,Date,RegExp,Function）。基本类型指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。

**基本数据类型是按值访问的**，因为可以直接操作保存在变量中的实际的值。引用类型的值是保存在内存中的对象，与其他语言不同，JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在**操作对象的引用**而不是实际的对象。 为此，引用类型的值是按引用访问的。

除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同：

- 如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。
- 当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。

看下面的代码：

```
// 基本类型值复制
var string1 = 'base type';
var string2 = string1;

// 引用类型值复制
var object1 = {a: 1};
var object2 = object1;

```

下图可以表示两种类型的变量的复制结果：

![](./img/clone.png)

至此，我们应该理解：在 JavaScript 中直接复制对象实际上是对引用的复制
，会导致两个亦是引用同一个对象，对任一亦是的个性都会反映到另一个变量上，这是一节总是原因所在。

### 二、深拷贝和浅拷贝的区别

- [浅拷贝](#21-浅拷贝)
- [深拷贝](#22-深拷贝)
- [浅拷贝与深拷贝区别](#23-浅拷贝与深拷贝区别)

#### 2.1 浅拷贝

创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，
拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

![](./img/clone01.png)

上图中，`SourceObject`是原对象，其中包含基本类型属性`filed1`和引用类型属性`refObj`。浅贝之后基本类型数据`field2`和`filed1`是不同属性，互不影响。但引用类型`refObj`仍然是同一个，改变之后会对另一个对象产生影响。

简单来说可以理解为浅拷贝只解决了第一层的问题，拷贝第一层的**基本类型值**，以及第一层的**引用类型地址**。

#### 2.2 深拷贝

深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。

![](./img/clone02.png)

#### 2.3 浅拷贝与深拷贝区别

| --     | 和原数据是否指向同一对象 | 第一层数据为基本数据类型 | 原数据中包含子对象       |
| ------ | ------------------------ | ------------------------ | ------------------------ |
| 赋值   | 是                       | 改变会使原数据一同改变   | 改变会使原数据一同改变   |
| 浅拷贝 | 否                       | 改变不会使原数据一同改变 | 改变会使原数据一同改变   |
| 深拷贝 | 否                       | 改变不会使原数据一同改变 | 改变不会使原数据一同改变 |

### 三、实现对象和数组浅拷贝

- 使用 Object.assign 方法
- 展开语法 Spread
- 使用 Object.getOwnPropertyNames 拷贝不可枚举的属性
- 使用 Object.getPrototypeOf 和 Object.getOwnPropertyDescriptor 拷贝原型与描述符
- 使用 slice 和 concat 方法

#### 3.1 使用 Object.assign 方法

`Object.assing()`用于将一个或多个源对象中的所有`可枚举的属性`值复制到目标对象

```
var object1 ={
    a:1,
    obj:{
        b:'string'
    }
};

// 浅拷贝
var copy = Object.assign({},object1);
// 改变原对象属性
object1.a =2;
object1.obj.b = 'newString';

console.log(copy.a); // 1
console.log(copy.obj.a);    // newString

```

上面代码改变对象 object1 之后，对象 copy 的基本属性保持不变。但是当改变对象 object1 中的对象`obj`时，对象 copy 相应的位置也发生了变化。

#### 3.2 展开语法 Spread

```
// tony
let a = {
    name: "tony",
    book: {
        title: 'You don`t Know JS',
        price: '45'
    }
}
let b = {...a};
console.log(b);

// {
// 	name: "tony",
// 	book: {title: "You Don't Know JS", price: "45"}
// }

a.name = 'change';
a.book.price = '55';
console.log(a);
// {
// 	name: "change",
// 	book: {title: "You Don't Know JS", price: "55"}
// }

console.log(b);
// {
// 	name: "tony",
// 	book: {title: "You Don't Know JS", price: "55"}
// }

```

通过代码可以看出实际效果和`Object.assign()`是一样的。

#### 3.3 使用 Object.getOwnPropertyNames 拷贝不可枚举的属性

```

```

#### 3.4 使用 Object.getPrototypeOf 和 Object.getOwnPropertyDescriptor 拷贝原型与描述符

```

```

#### 3.5 使用 slice 和 concat 方法

```

```

### 四、实现对象和数组深拷贝

- 使用 JSON.stringify 和 JSON.parse 方法
- 使用递归
- 使用队列

#### 4.1 使用 JSON.stringify 和 JSON.parse 方法

```

```

#### 4.2 使用递归

```

```

#### 4.3 使用队列

```

```

### 参考资料

- [深入理解 JavaScript 对象和数组拷贝](https://juejin.im/post/5a00226b5188255695390a74)
- [详细解析赋值、浅拷贝和深拷贝的区别](https://muyiy.vip/blog/4/4.1.html)
- [JavaScript 专题之深浅拷贝](https://github.com/mqyqingfeng/Blog/issues/32)
- [深入剖析 JavaScript 的深复制](https://jerryzou.com/posts/dive-into-deep-clone-in-javascript/)

## 联系作者

<div align="center">
    <p>
        平凡世界，贵在坚持。
    </p>
    <img src="../img/contact.png" />
</div>
