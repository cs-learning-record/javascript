![image](../img/timg.jpg)
<br>

## 前言

装饰器是一种与类想着的语法，用来注释或修改类和类方法。

装饰器是一种函数，写成`@+函数名`。它可以放在类和类方法的定义前面。

```
@frozen class Foo{
 @configuirable(false)
 @enumerable(true)
 method(){}

@throttle(500)
expendsiveMethod(){}
}
```

上面代码一共使用了四个装饰器，一个用在类本身，另外三个用在类方法。它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能。

## 关于作者

一个工作八年的草根程序员。

## 内容

- 类的装饰
- 方法的装饰
- 应用

### 一、类的装饰

装饰器可以用来装饰整个类。

```
@testable
class MyTestableClass{
    // ...
}

function testable(target){
    target.isTestable = true;
}

MyTestableClass.isTestable  // true
```

上面代码中，`@testable`就是一个装饰器。它修改了`MyTestableClass`这个类的行为，为它加上了静态属性`isTestable`。`testable`函数的参数`target`是`MyTestableClass`类本身。

### 二、方法的装饰

装饰器不仅可以装饰类，还可以装饰类的属性。

```

```

### 三、应用

- log
- autobind
- debounce
- mixin

#### 3.1 log

#### 3.2 autobind

#### 3.3 debounce

#### 3.4 mixin

用于将对象的方法混入 Class 中：

```
const SingerMixin = {
    sing(sound){
        alert(sound);
    }
};

const FlyMixin = {
    // All types of property descriptors are supported
    get speed() {},
    fly(){},
    land(){}
}

@mixin(SingerMixin,FlyMixin)
class Bird{
    singMatingCall(){
        this.sing('tweet tweet');
    }
}

var bird = new Bird();
bird.singMatingCall();
// alerts "tweet tweet"
```

mixin 的一个简单实现如下：

```
function mixin(...mixins){
    return target =>{
        if(!mixins.length){
            throw new SyntaxError
        }
    }
}
```

### 参考资料

## 联系作者

<div align="center">
    <p>
        平凡世界，贵在坚持。
    </p>
    <img src="../img/contact.png" />
</div>
