![image](../img/timg.jpg)
<br>

## 前言

ES6中数组增加了扩展运算符、from()、of()、includes()、fill()等方法。

## 关于作者

一个工作八年的草根程序员。

## 内容

- [扩展运算符](#一扩展运算符)
- [扩展运算符的应用](#二扩展运算符的应用)
- [Array.from()](#三arrayfrom)
- [Array.of()](#四arrayof)
- [数组实例的 copyWithin()](#五数组实例的-copywithin)
- [数组实例的 find() 和 findIndex()](#六数组实例的-find-和-findindex)
- 数组实例的 fill()
- 数组实例的 entries()，keys() 和 values()
- 数组实例的 includes()
- 数组实例的 flat()，flatMap()

### 一、扩展运算符

扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。

```
console.log(...[1,2,3])
// 1 2 3

[...document.querySelectorAll('div')]

// [<div>,<div>,<div>]
```

#### 替代数组的 apply 方法

由于扩展运算符可以展开数组，所以不再需要`apply`方法，将数组转为函数的参数了。

```
// ES5的写法
function f(x,y,z){
    // ...
}
var args = [0,1,2];
f.apply(null,args);

// ES6的写法
function f(x,y,z){
    // ...
}
var args = [0,1,2];
f(...args);
```

下面是扩展运算符取代`apply`方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。

```
// ES5 的写法
Math.max.apply(null,[14,3,77]);

// ES6 的写法
Math.max(...[14,3,77]);

```

### 二、扩展运算符的应用

- [复制数组](#21-复制数组)
- [合并数组](#22-合并数组)
- [与解构赋值结合](#23-与解构赋值结合)
- [字符串](#24-字符串)
- [实现了 Iterator 接口的对象](#25-实现了-iterator-接口的对象)
- [Map 和 Set 结构，Generator 函数](#26-map-和-set-结构generator-函数)

#### 2.1 复制数组

数组是复合数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。

```
const a1 = [1, 2];
// 写法一
const a2 = [...a1];
// 写法二
const [...a2] = a1;
```

#### 2.2 合并数组

扩展运算符提供了数组合并的新写法，

```
// ES5
[1, 2].concat(more)
// ES6
[1, 2, ...more]

var arr1 = ['a', 'b'];
var arr2 = ['c'];
var arr3 = ['d', 'e'];

// ES5的合并数组
arr1.concat(arr2, arr3);
// [ 'a', 'b', 'c', 'd', 'e' ]

// ES6的合并数组
[...arr1, ...arr2, ...arr3]
// [ 'a', 'b', 'c', 'd', 'e' ]
```

#### 2.3 与解构赋值结合

扩展运算符可以与解构赋值结合起来，用于生成数组。如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。

```
const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]
```

#### 2.4 字符串

扩展运算符还可以将字符串转为真正的数组。

```
[...'hello']
// ["h","e","l","l","o"]

```

#### 2.5 实现了 Iterator 接口的对象

任何 Iterator 接口的对象，都可以用扩展去处符转为真正的数组。对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。

```
var nodeList = document.querySelectorAll('div');
var array = [...nodeList];
```

#### 2.6 Map 和 Set 结构，Generator 函数

扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。

```
let map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

let arr = [...map.keys()]; // [1, 2, 3]
```

### 三、Array.from()

### 四、Array.of()

### 五、数组实例的 copyWithin()

### 六、数组实例的 find() 和 findIndex()

### 七、数组实例的 fill()

### 八、数组实例的 entries()，keys() 和 values()

### 九、数组实例的 includes()

### 十、数组实例的 flat()，flatMap()

### 参考资料

- [《ECMAScript 6 入门》 第三版](https://yjhenan.gitbooks.io/-ecmascript-6/content/docs/array.html)
- [ECMAScript 6 入门](http://es6.ruanyifeng.com/#docs/array#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6)

## 联系作者

<div align="center">
    <p>
        平凡世界，贵在坚持。
    </p>
    <img src="../img/contact.png" />
</div>
